import type { IntentCategory, LayoutOption } from '@/lib/creation-flow-types'

export type AutoDensity = 'low' | 'mid' | 'high'
export type AutoTone = 'editorial' | 'comercial' | 'institucional' | 'didactico' | 'dinamico'

export interface AutoThumbnailSpec {
    family: 'grid' | 'split' | 'process' | 'radial' | 'card' | 'list' | 'stat'
    idTokens: string[]
    focus: string
}

export interface AutoGeneratedComposition {
    layout: LayoutOption
    modeBasic: boolean
    modeAdvanced: boolean
    thumbnailSpec: AutoThumbnailSpec
}

interface AutoGenerateInput {
    intent: IntentCategory
    goal: string
    count: number
    textDensity: AutoDensity
    tone: AutoTone
    seed?: number
    existingIds?: Iterable<string>
}

interface ArchetypeDefinition {
    idToken: string
    name: string
    description: string
    promptInstruction: string
    textZone: LayoutOption['textZone']
    thumbnailFamily: AutoThumbnailSpec['family']
    thumbnailTokens: string[]
    basicFriendly: boolean
    structuralLines: string[]
}

const ARCHETYPES: Record<string, ArchetypeDefinition> = {
    grid_bento: {
        idToken: 'grid-bento',
        name: 'Mosaico de Valor',
        description: 'Reticula irregular con foco principal y modulos de apoyo.',
        promptInstruction: 'Modular bento-style composition with one dominant pane and organized supporting cells.',
        textZone: 'left',
        thumbnailFamily: 'grid',
        thumbnailTokens: ['grid', 'mosaic', 'catalogo'],
        basicFriendly: true,
        structuralLines: [
            'Define una celda dominante para el mensaje principal y evita competir con apoyos secundarios.',
            'Reserva una franja limpia para texto continuo fuera del bloque dominante.',
            'Distribuye modulos secundarios con separaciones claras y jerarquia de tamano.',
            'Mantiene ritmo visual estable sin superponer piezas en la zona de lectura.',
            'Ancla el logo principal en base con presencia discreta.',
        ],
    },
    split_hero: {
        idToken: 'split-hero',
        name: 'Split Hero',
        description: 'Escena partida con protagonista y columna funcional.',
        promptInstruction: 'Asymmetric split composition with hero panel and protected text lane.',
        textZone: 'left',
        thumbnailFamily: 'split',
        thumbnailTokens: ['split', 'benefit', 'versus'],
        basicFriendly: true,
        structuralLines: [
            'Divide el lienzo en dos zonas asimetricas y da prioridad al bloque hero.',
            'Protege un carril de texto estable en el lado secundario.',
            'Usa contrastes de escala, no de ruido, para separar jerarquia.',
            'Evita cruces diagonales que invadan la lectura principal.',
            'Mantiene logos en esquinas opuestas con peso claramente secundario.',
        ],
    },
    radial_spotlight: {
        idToken: 'radial-spotlight',
        name: 'Foco Radial',
        description: 'Centro protagonista con ondas de apoyo periferico.',
        promptInstruction: 'Radial spotlight composition with central focus and controlled orbit supports.',
        textZone: 'bottom',
        thumbnailFamily: 'radial',
        thumbnailTokens: ['radial', 'spotlight', 'hero'],
        basicFriendly: false,
        structuralLines: [
            'Ubica el foco visual principal en centro y despeja un anillo de respiracion.',
            'Distribuye apoyos en periferia sin competir con el nucleo.',
            'Reserva texto en una banda limpia fuera del eje radial.',
            'Controla conectores para sugerir energia sin saturacion.',
            'Ancla logo principal en base y evita marcas dentro del nucleo.',
        ],
    },
    process_z: {
        idToken: 'process-z',
        name: 'Ruta en Z',
        description: 'Recorrido secuencial para explicar pasos o servicio.',
        promptInstruction: 'Z-path process composition with directional anchors and protected headline lane.',
        textZone: 'top',
        thumbnailFamily: 'process',
        thumbnailTokens: ['process', 'timeline', 'pasos'],
        basicFriendly: true,
        structuralLines: [
            'Traza un recorrido en Z con nodos de lectura claramente numerables.',
            'Reserva cabecera limpia para titular y subtitulo breve.',
            'Alinea bloques de contenido a la ruta y mantiene separacion entre nodos.',
            'Evita ornamentacion sobre flechas o conectores para no romper flujo.',
            'Mantiene logo principal en la base del recorrido con baja interferencia.',
        ],
    },
    stacked_cards: {
        idToken: 'stacked-cards',
        name: 'Tarjetas Apiladas',
        description: 'Capas editoriales con profundidad y orden de lectura.',
        promptInstruction: 'Layered card composition with clear depth hierarchy and protected caption zone.',
        textZone: 'bottom',
        thumbnailFamily: 'card',
        thumbnailTokens: ['card', 'frame', 'tarjeta'],
        basicFriendly: true,
        structuralLines: [
            'Construye capas de tarjetas con offsets suaves y jerarquia de profundidad.',
            'Protege una zona de caption sin solapamientos.',
            'Usa una tarjeta dominante para mensaje principal y secundarias para apoyo.',
            'Mantiene bordes y sombras consistentes para ordenar lectura.',
            'Ancla logo principal en pie de la composicion con firma discreta.',
        ],
    },
    diagonal_energy: {
        idToken: 'diagonal-energy',
        name: 'Diagonal Dinamica',
        description: 'Eje diagonal de tension controlada para campanas activas.',
        promptInstruction: 'Diagonal momentum composition with protected counter-balance text lane.',
        textZone: 'right',
        thumbnailFamily: 'split',
        thumbnailTokens: ['diagonal', 'versus', 'split'],
        basicFriendly: false,
        structuralLines: [
            'Define un eje diagonal dominante para direccionar la atencion.',
            'Reserva una zona compensada de texto en el lado opuesto al empuje visual.',
            'Coloca un punto de tension principal y apoyos de menor escala en el recorrido.',
            'Evita que elementos decorativos crucen la zona de texto.',
            'Mantiene marca principal en extremo de salida con presencia secundaria.',
        ],
    },
    timeline_vertical: {
        idToken: 'timeline-vertical',
        name: 'Linea Vertical',
        description: 'Cadena temporal limpia para hitos o anuncios.',
        promptInstruction: 'Vertical timeline composition with ordered milestones and protected side text block.',
        textZone: 'left',
        thumbnailFamily: 'process',
        thumbnailTokens: ['timeline', 'process', 'list'],
        basicFriendly: true,
        structuralLines: [
            'Construye una linea vertical de hitos con ritmo constante.',
            'Reserva una columna lateral para texto continuo y encabezado.',
            'Asigna un nodo principal y subnodos con tamano decreciente.',
            'Evita cruces de conectores y ruido entre hitos.',
            'Ancla logos fuera de la linea para no romper continuidad.',
        ],
    },
    checklist_blocks: {
        idToken: 'checklist-blocks',
        name: 'Checklist Modular',
        description: 'Bloques funcionales para listas y validaciones.',
        promptInstruction: 'Checklist-oriented block composition with strong scanning rhythm and safe text header.',
        textZone: 'top',
        thumbnailFamily: 'list',
        thumbnailTokens: ['list', 'check', 'memo'],
        basicFriendly: true,
        structuralLines: [
            'Organiza bloques en lectura rapida con puntos de verificacion visibles.',
            'Reserva cabecera limpia para claim principal.',
            'Agrupa elementos por prioridad usando tamano y espaciado, no color extremo.',
            'Mantiene separacion consistente entre items para escaneo instantaneo.',
            'Ubica logo principal en pie con contraste moderado.',
        ],
    },
    before_after: {
        idToken: 'before-after',
        name: 'Antes y Despues',
        description: 'Comparativa binaria con frontera clara.',
        promptInstruction: 'Before/after comparison composition with explicit divide and protected title lane.',
        textZone: 'top',
        thumbnailFamily: 'split',
        thumbnailTokens: ['comparison', 'versus', 'split'],
        basicFriendly: true,
        structuralLines: [
            'Divide la escena en dos estados comparables con frontera inequivoca.',
            'Reserva una banda de titulo fuera del eje de comparacion.',
            'Mantiene correspondencia de escala entre ambos lados.',
            'Evita overlays que oculten la frontera conceptual.',
            'Logo principal en base centrada o esquina inferior estable.',
        ],
    },
    hub_spoke: {
        idToken: 'hub-spoke',
        name: 'Nucleo y Ramificaciones',
        description: 'Centro semantico con satelites explicativos.',
        promptInstruction: 'Hub-and-spoke composition with central concept and distributed support nodes.',
        textZone: 'center',
        thumbnailFamily: 'radial',
        thumbnailTokens: ['radial', 'process', 'ecosystem'],
        basicFriendly: false,
        structuralLines: [
            'Coloca un nucleo conceptual dominante y satelites de apoyo alrededor.',
            'Reserva texto principal en area protegida fuera del circulo de satelites.',
            'Conecta satelites con trazos minimos para mantener claridad.',
            'Define prioridad de lectura del centro hacia periferia.',
            'Ancla marca en base y evita logos dentro de conexiones.',
        ],
    },
}

const INTENT_ARCHETYPES: Partial<Record<IntentCategory, string[]>> = {
    servicio: ['split_hero', 'grid_bento', 'process_z', 'hub_spoke', 'checklist_blocks'],
    oferta: ['radial_spotlight', 'split_hero', 'stacked_cards', 'diagonal_energy'],
    comunicado: ['stacked_cards', 'timeline_vertical', 'checklist_blocks', 'split_hero'],
    pasos: ['process_z', 'timeline_vertical', 'checklist_blocks', 'diagonal_energy'],
    catalogo: ['grid_bento', 'stacked_cards', 'split_hero', 'before_after'],
    comparativa: ['before_after', 'split_hero', 'diagonal_energy', 'checklist_blocks'],
    dato: ['checklist_blocks', 'timeline_vertical', 'grid_bento', 'hub_spoke'],
}

const DENSITY_LINES: Record<AutoDensity, string> = {
    low: 'Mantiene aire amplio entre bloques y limita a una capa secundaria de apoyo.',
    mid: 'Equilibra densidad y respiracion con dos niveles de apoyo visibles.',
    high: 'Aumenta capacidad informativa con modulos compactos pero legibles y sin solape.',
}

const TONE_LINES: Record<AutoTone, string> = {
    editorial: 'Prioriza ritmo tipografico editorial y jerarquia serena.',
    comercial: 'Refuerza conversion con foco claro, contraste funcional y CTA respirable.',
    institucional: 'Mantiene formalidad sobria y orden estable de lectura.',
    didactico: 'Favorece progresion pedagogica y anclas visuales explicativas.',
    dinamico: 'Incrementa sensacion de movimiento sin comprometer claridad textual.',
}

function slugify(value: string): string {
    return value
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '')
}

function createRandom(seed: number) {
    let state = (seed >>> 0) || 123456789
    return () => {
        state = (1664525 * state + 1013904223) >>> 0
        return state / 0xffffffff
    }
}

function shuffle<T>(items: T[], random: () => number): T[] {
    const copy = [...items]
    for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(random() * (i + 1))
        const tmp = copy[i]
        copy[i] = copy[j]
        copy[j] = tmp
    }
    return copy
}

function uniqueId(baseId: string, existingIds: Set<string>): string {
    let candidate = baseId
    let n = 2
    while (existingIds.has(candidate)) {
        candidate = `${baseId}-v${n}`
        n += 1
    }
    existingIds.add(candidate)
    return candidate
}

function pickArchetypes(intent: IntentCategory, count: number, random: () => number): string[] {
    const preferred = INTENT_ARCHETYPES[intent] || Object.keys(ARCHETYPES)
    const shuffled = shuffle(preferred.filter((key) => Boolean(ARCHETYPES[key])), random)
    if (count <= shuffled.length) return shuffled.slice(0, count)

    const result = [...shuffled]
    while (result.length < count) {
        result.push(shuffled[Math.floor(random() * shuffled.length)])
    }
    return result
}

function composeStructuralPrompt(archetype: ArchetypeDefinition, density: AutoDensity, tone: AutoTone, goal: string): string {
    return [
        ...archetype.structuralLines,
        DENSITY_LINES[density],
        TONE_LINES[tone],
        `Alinea la composicion al objetivo: ${goal.trim() || 'comunicar con claridad'}.`,
    ].join('\n')
}

export function generateLegacyAutoCompositions(input: AutoGenerateInput): AutoGeneratedComposition[] {
    const count = Math.max(1, Math.min(12, input.count))
    const random = createRandom(input.seed ?? 42)
    const existingIds = new Set<string>(input.existingIds || [])
    const selectedArchetypes = pickArchetypes(input.intent, count, random)

    return selectedArchetypes.map((archetypeKey) => {
        const archetype = ARCHETYPES[archetypeKey]
        const baseId = slugify(`${input.intent}-${archetype.idToken}`)
        const id = uniqueId(baseId, existingIds)

        const layout: LayoutOption = {
            id,
            name: `${archetype.name} (${input.intent})`,
            description: archetype.description,
            svgIcon: 'Layout',
            textZone: archetype.textZone,
            promptInstruction: archetype.promptInstruction,
            structuralPrompt: composeStructuralPrompt(archetype, input.textDensity, input.tone, input.goal),
            skillVersion: 'auto-v1',
        }

        const thumbnailSpec: AutoThumbnailSpec = {
            family: archetype.thumbnailFamily,
            idTokens: archetype.thumbnailTokens,
            focus: `${archetype.thumbnailFamily} composition tuned for ${input.intent}`,
        }

        return {
            layout,
            modeBasic: archetype.basicFriendly && input.textDensity !== 'high',
            modeAdvanced: true,
            thumbnailSpec,
        }
    })
}
